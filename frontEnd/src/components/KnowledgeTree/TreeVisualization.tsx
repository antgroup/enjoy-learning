import React, { useRef, useEffect } from 'react';
import * as echarts from 'echarts';
import { TreeVisualizationProps, TreeNodeData } from './types';

const TreeVisualization: React.FC<TreeVisualizationProps> = ({
  loading,
  treeListLoading,
  currentTreeId,
  treeData,
  searchTerm,
  onNodeClick,
  setCurrentNodeId,
  loadTreeData
}) => {
  const chartRef = useRef<HTMLDivElement>(null);
  const chartInstanceRef = useRef<echarts.ECharts | null>(null);
  const isInitializedRef = useRef<boolean>(false);
  const animationRef = useRef<number | null>(null);

  // 获取层级颜色
  const getColorByLevel = (level: number, isAutoGenerated: boolean = false): string => {
    const colors = [
      "#1890ff", // 根节点 - 蓝色
      "#52c41a", // 第一层 - 绿色
      "#fa8c16", // 第二层 - 橙色
      "#722ed1", // 第三层 - 紫色
      "#eb2f96", // 第四层 - 粉色
      "#13c2c2", // 第五层 - 青色
    ];
    
    let color = colors[level % colors.length];
    
    // AI自动生成的节点使用稍微透明的颜色
    if (isAutoGenerated) {
      color = color + 'CC'; // 添加透明度
    }
    
    return color;
  };

  // 检查是否有问号节点
  const hasQuestionMarkNodes = (data: TreeNodeData): boolean => {
    if (data.name === '？' || data.name === '?') {
      return true;
    }
    
    if (data.children) {
      return data.children.some(child => hasQuestionMarkNodes(child));
    }
    
    return false;
  };

  // 为树数据添加特殊样式
  const addSpecialStyles = (data: TreeNodeData): TreeNodeData => {
    const isQuestionMark = data.name === '？' || data.name === '?';
    
    const processedNode: TreeNodeData = {
      ...data,
      // 问号节点的连接线样式（连接到父节点的线）
      lineStyle: isQuestionMark ? {
        type: 'dashed',
        color: '#ff6b6b',
        width: 2,
        opacity: 0.8
      } : undefined,
      // 问号节点的样式
      itemStyle: isQuestionMark ? {
        ...data.itemStyle,
        color: '#ff6b6b',
        borderColor: '#ff4d4f',
        borderWidth: 2,
        shadowBlur: 10,
        shadowColor: 'rgba(255, 107, 107, 0.5)',
        shadowOffsetY: 0
      } : data.itemStyle
    };

    if (data.children) {
      processedNode.children = data.children.map(child => 
        addSpecialStyles(child)
      );
    }

    return processedNode;
  };

  // 高亮搜索结果
  const highlightSearchResults = (data: TreeNodeData, searchTerm: string): TreeNodeData => {
    const isMatch = searchTerm && (
      data.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      data.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      data.keywords?.some(keyword => keyword.toLowerCase().includes(searchTerm.toLowerCase()))
    );
    
    const highlightedNode: TreeNodeData = {
      ...data,
      itemStyle: {
        ...data.itemStyle,
        color: isMatch ? '#ff4d4f' : data.itemStyle?.color,
        borderColor: isMatch ? '#ff4d4f' : (data.itemStyle?.borderColor || '#fff'),
        borderWidth: isMatch ? 3 : (data.itemStyle?.borderWidth || 2)
      }
    };

    if (data.children) {
      highlightedNode.children = data.children.map(child => 
        highlightSearchResults(child, searchTerm)
      );
    }

    return highlightedNode;
  };

  // 更新图表
  const updateChart = (searchTerm: string = '') => {
    if (!chartInstanceRef.current || !treeData) {
      return;
    }

    // 添加特殊样式
    let processedData = addSpecialStyles(treeData);
    
    // 应用搜索高亮
    processedData = searchTerm ? 
      highlightSearchResults(processedData, searchTerm) : 
      processedData;

    const option = {
      // 禁用tooltip，只使用底部详情面板
      tooltip: {
        show: false
      },
      series: [
        {
          type: 'tree',
          data: [processedData],
          left: '2%',
          right: '2%',
          top: '8%',
          bottom: '8%',
          
          // 使用空心圆形符号，更加优雅
          symbol: 'emptyCircle',
          symbolSize: (value: number, params: any) => {
            // 根据节点层级和进度调整大小
            const baseSize = params.data.children ? 14 : 10;
            const progressBonus = (params.data.progress || 0) / 100 * 6;
            const levelBonus = Math.max(0, 3 - (params.data.level || 0)) * 2;
            return baseSize + progressBonus + levelBonus;
          },
          
          // 从下到上的方向
          orient: 'BT',
          
          // 禁用展开收起功能，显示完整树结构
          expandAndCollapse: false,
          
          // 启用缩放和拖拽功能
          roam: true,
          
          // 显示所有层级
          initialTreeDepth: -1,
          
          // 标签配置
          label: {
            show: true,
            position: 'bottom',
            rotate: 0,
            verticalAlign: 'top',
            align: 'center',
            fontSize: 11,
            fontWeight: 'normal',
            color: '#333',
            distance: 8,
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            borderColor: 'rgba(0, 0, 0, 0.1)',
            borderWidth: 1,
            borderRadius: 4,
            padding: [2, 6]
          },
          
          // 叶子节点的标签配置
          leaves: {
            label: {
              position: 'bottom',
              rotate: 0,
              verticalAlign: 'top',
              align: 'center',
              fontSize: 10,
              color: '#666',
              backgroundColor: 'rgba(255, 255, 255, 0.8)',
              borderColor: 'rgba(0, 0, 0, 0.05)',
              borderWidth: 1,
              borderRadius: 3,
              padding: [1, 4]
            }
          },
          
          // 线条样式 - 使用固定样式
          lineStyle: {
            color: '#ccc',
            width: 1.5,
            curveness: 0.3,
            type: 'solid'
          },
          
          // 节点样式
          itemStyle: {
            borderWidth: 2,
            borderColor: '#fff',
            shadowBlur: 8,
            shadowColor: 'rgba(0, 0, 0, 0.1)',
            shadowOffsetY: 2
          },
          
          // 强调样式
          emphasis: {
            focus: 'descendant',
            itemStyle: {
              shadowBlur: 12,
              shadowColor: 'rgba(0, 0, 0, 0.2)',
              borderWidth: 3
            },
            lineStyle: {
              width: 2,
              color: '#666'
            },
            label: {
              fontSize: 12,
              fontWeight: 'bold',
              backgroundColor: 'rgba(255, 255, 255, 1)',
              borderWidth: 2
            }
          },
          
          // 动画配置
          animationDuration: 800,
          animationDurationUpdate: 600,
          animationEasing: 'cubicOut'
        }
      ]
    };

    chartInstanceRef.current.setOption(option, true);

    // 如果有问号节点，添加闪烁动画
    if (hasQuestionMarkNodes(treeData)) {
      startBlinkingAnimation();
    } else {
      stopBlinkingAnimation();
    }
  };

  // 开始闪烁动画
  const startBlinkingAnimation = () => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }

    let opacity = 0.3;
    let increasing = true;
    
    const animate = () => {
      if (increasing) {
        opacity += 0.015;
        if (opacity >= 1) {
          increasing = false;
        }
      } else {
        opacity -= 0.015;
        if (opacity <= 0.3) {
          increasing = true;
        }
      }

      // 更新问号节点的透明度
      if (chartInstanceRef.current && treeData) {
        const updatedData = updateNodeOpacity(treeData, opacity);
        const option = {
          series: [{
            data: [updatedData]
          }]
        };
        chartInstanceRef.current.setOption(option, false);
      }

      animationRef.current = requestAnimationFrame(animate);
    };

    animationRef.current = requestAnimationFrame(animate);
  };

  // 停止闪烁动画
  const stopBlinkingAnimation = () => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
      animationRef.current = null;
    }
  };

  // 更新节点透明度
  const updateNodeOpacity = (data: TreeNodeData, opacity: number): TreeNodeData => {
    const isQuestionMark = data.name === '？' || data.name === '?';
    
    const updatedNode: TreeNodeData = {
      ...data,
      itemStyle: isQuestionMark ? {
        ...data.itemStyle,
        opacity: opacity
      } : data.itemStyle
    };

    if (data.children) {
      updatedNode.children = data.children.map(child => 
        updateNodeOpacity(child, opacity)
      );
    }

    return updatedNode;
  };

  // 初始化图表实例 - 当有数据且容器准备好时初始化，但只初始化一次
  useEffect(() => {
    if (chartRef.current && !isInitializedRef.current && treeData) {
      console.log('初始化图表实例');
      const chart = echarts.init(chartRef.current);
      chartInstanceRef.current = chart;
      isInitializedRef.current = true;
      
      // 处理节点点击
      chart.on('click', (params: any) => {
        if (params.componentType === 'series' && params.data) {
          const nodeData = params.data as TreeNodeData;
          if (nodeData.nodeId) {
            setCurrentNodeId(nodeData.nodeId);
          }
          onNodeClick(nodeData);
        }
      });

      // 处理窗口大小变化
      const handleResize = () => {
        chart.resize();
      };
      window.addEventListener('resize', handleResize);

      // 立即更新图表数据
      updateChart(searchTerm);

      // 清理函数
      return () => {
        window.removeEventListener('resize', handleResize);
        stopBlinkingAnimation();
        chart.dispose();
        chartInstanceRef.current = null;
        isInitializedRef.current = false;
      };
    }
  }, [treeData, onNodeClick, setCurrentNodeId, searchTerm]);

  // 更新图表数据 - 当数据变化时只更新数据，不重新创建图表
  useEffect(() => {
    if (chartInstanceRef.current && treeData && isInitializedRef.current) {
      console.log('更新图表数据');
      updateChart(searchTerm);
    }
  }, [treeData, searchTerm]);

  // 处理图表实例的清理
  useEffect(() => {
    return () => {
      if (chartInstanceRef.current) {
        stopBlinkingAnimation();
        chartInstanceRef.current.dispose();
        chartInstanceRef.current = null;
        isInitializedRef.current = false;
      }
    };
  }, []);

  return (
    <div className="knowledge-tree-container">
      {(loading || treeListLoading) ? (
        <div className="loading">
          {treeListLoading ? '正在获取知识树列表...' : '加载中...'}
        </div>
      ) : !currentTreeId ? (
        <div className="empty-state">没有可用的知识树</div>
      ) : !treeData ? (
        <div className="empty-state">暂无数据</div>
      ) : (
        <div ref={chartRef} style={{ width: '100%', height: '100%' }}></div>
      )}
    </div>
  );
};

export default TreeVisualization;

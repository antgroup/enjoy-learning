import React, { useState, useEffect, useRef } from 'react';
import * as echarts from 'echarts';
import { knowledgeTreeApi } from '../../api/index';
import './index.css';

interface KnowledgeNode {
  id: string;
  name: string;
  category: string;
  value: number;
  symbolSize: number;
  itemStyle: {
    color: string;
  };
  label: {
    show: boolean;
  };
  // åŸå§‹æ•°æ®
  nodeId?: string;
  description?: string;
  progress?: number;
  keywords?: string[];
  associatedNotesCount?: number;
  isAutoGenerated?: boolean;
  level?: number;
}

interface KnowledgeLink {
  source: string;
  target: string;
  lineStyle: {
    color: string;
    width: number;
  };
}

const KnowledgeMap: React.FC = () => {
  const chartRef = useRef<HTMLDivElement>(null);
  const chartInstanceRef = useRef<echarts.ECharts | null>(null);
  const [selectedNode, setSelectedNode] = useState<any>(null);
  const [showNodeDetail, setShowNodeDetail] = useState(false);
  const [loading, setLoading] = useState(true);
  const [currentTreeId, setCurrentTreeId] = useState<number | null>(null);
  const [treeListLoading, setTreeListLoading] = useState(true);

  // è·å–å±‚çº§é¢œè‰²
  const getColorByLevel = (level: number, isAutoGenerated: boolean = false): string => {
    const colors = [
      '#ff6b6b',  // æ ¹èŠ‚ç‚¹ - äº®çº¢è‰²
      '#51cf66',  // ç¬¬ä¸€å±‚ - äº®ç»¿è‰²
      '#74c0fc',  // ç¬¬äºŒå±‚ - äº®è“è‰²
      '#ffd43b',  // ç¬¬ä¸‰å±‚ - äº®é»„è‰²
      '#da77f2',  // ç¬¬å››å±‚ - äº®ç´«è‰²
      '#22d3ee',  // ç¬¬äº”å±‚ - äº®é’è‰²
    ];
    
    let color = colors[level % colors.length];
    
    // AIè‡ªåŠ¨ç”Ÿæˆçš„èŠ‚ç‚¹ä½¿ç”¨ç¨å¾®æš—ä¸€äº›çš„é¢œè‰²
    if (isAutoGenerated) {
      // å°†é¢œè‰²è°ƒæš—
      color = color.replace('#', '#') + '80'; // æ·»åŠ é€æ˜åº¦
    }
    
    return color;
  };

  // å°†æ ‘å½¢æ•°æ®è½¬æ¢ä¸ºåŠ›å‘å›¾æ•°æ®
  const convertToForceData = (node: any, level: number = 0, parentId?: string): { nodes: KnowledgeNode[], links: KnowledgeLink[] } => {
    const nodes: KnowledgeNode[] = [];
    const links: KnowledgeLink[] = [];
    
    const nodeId = node.nodeId || `${level}_${node.name}`;
    
    const forceNode: KnowledgeNode = {
      id: nodeId,
      name: node.name || 'æœªå‘½åèŠ‚ç‚¹',
      category: `ç¬¬${level}å±‚`,
      value: node.progress || 0,
      symbolSize: level === 0 ? 60 : Math.max(30, 50 - level * 5), // æ ¹èŠ‚ç‚¹æ›´å¤§
      itemStyle: {
        color: getColorByLevel(level, node.isAutoGenerated)
      },
      label: {
        show: true
      },
      // ä¿å­˜åŸå§‹æ•°æ®
      nodeId: node.nodeId,
      description: node.description || '',
      progress: node.progress || 0,
      keywords: node.keywords || [],
      associatedNotesCount: node.associatedNotesCount || 0,
      isAutoGenerated: node.isAutoGenerated || false,
      level
    };

    nodes.push(forceNode);

    // å¦‚æœæœ‰çˆ¶èŠ‚ç‚¹ï¼Œåˆ›å»ºè¿æ¥
    if (parentId) {
      const link: KnowledgeLink = {
        source: parentId,
        target: nodeId,
        lineStyle: {
          color: '#999',
          width: Math.max(1, 3 - level * 0.5)
        }
      };
      links.push(link);
    }

    // å¤„ç†å­èŠ‚ç‚¹
    if (node.children && node.children.length > 0) {
      node.children.forEach((child: any) => {
        const childData = convertToForceData(child, level + 1, nodeId);
        nodes.push(...childData.nodes);
        links.push(...childData.links);
      });
    }

    return { nodes, links };
  };

  // è·å–çŸ¥è¯†æ ‘åˆ—è¡¨å¹¶è®¾ç½®å½“å‰æ ‘ID
  const loadTreeList = async () => {
    try {
      setTreeListLoading(true);
      console.log('ğŸ—ºï¸ å¼€å§‹è·å–çŸ¥è¯†æ ‘åˆ—è¡¨...');
      const response = await knowledgeTreeApi.getTreeList();
      
      console.log('ğŸ—ºï¸ çŸ¥è¯†æ ‘åˆ—è¡¨å“åº”:', response);
      
      if (response.data && Array.isArray(response.data) && response.data.length > 0) {
        // ä½¿ç”¨ç¬¬ä¸€ä¸ªçŸ¥è¯†æ ‘çš„ID
        const firstTree = response.data[0];
        // @ts-ignore
        setCurrentTreeId(firstTree.treeIdStr);
        console.log('ğŸ—ºï¸ è·å–åˆ°çŸ¥è¯†æ ‘åˆ—è¡¨ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªæ ‘ID:', firstTree.treeIdStr, 'æ ‘åç§°:', firstTree.name);
      } else {
        console.warn('âš ï¸ æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„çŸ¥è¯†æ ‘ï¼Œå“åº”æ•°æ®:', response);
        setCurrentTreeId(null);
      }
    } catch (error) {
      console.error('âŒ è·å–çŸ¥è¯†æ ‘åˆ—è¡¨å¤±è´¥:', error);
      // å¦‚æœè·å–å¤±è´¥ï¼Œå›é€€åˆ°é»˜è®¤å€¼
      console.log('ğŸ”„ å›é€€åˆ°é»˜è®¤æ ‘ID: 1');
      setCurrentTreeId(1);
    } finally {
      setTreeListLoading(false);
    }
  };

  // åˆ›å»ºæµ‹è¯•æ•°æ®
  const createTestData = (): { nodes: KnowledgeNode[], links: KnowledgeLink[] } => {
    const nodes: KnowledgeNode[] = [
      {
        id: 'test_root',
        name: 'æµ‹è¯•æ ¹èŠ‚ç‚¹',
        category: 'ç¬¬0å±‚',
        value: 80,
        symbolSize: 60,
        itemStyle: { color: '#ff6b6b' },
        label: { show: true },
        description: 'è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æ ¹èŠ‚ç‚¹',
        progress: 80,
        keywords: ['æµ‹è¯•', 'æ ¹èŠ‚ç‚¹'],
        associatedNotesCount: 5,
        isAutoGenerated: false,
        level: 0
      },
      {
        id: 'test_child1',
        name: 'ç®—æ³•åŸºç¡€',
        category: 'ç¬¬1å±‚',
        value: 60,
        symbolSize: 45,
        itemStyle: { color: '#51cf66' },
        label: { show: true },
        description: 'ç®—æ³•åŸºç¡€çŸ¥è¯†',
        progress: 60,
        keywords: ['ç®—æ³•', 'åŸºç¡€'],
        associatedNotesCount: 3,
        isAutoGenerated: false,
        level: 1
      },
      {
        id: 'test_child2',
        name: 'æ•°æ®ç»“æ„',
        category: 'ç¬¬1å±‚',
        value: 40,
        symbolSize: 45,
        itemStyle: { color: '#51cf66' },
        label: { show: true },
        description: 'æ•°æ®ç»“æ„ç›¸å…³çŸ¥è¯†',
        progress: 40,
        keywords: ['æ•°æ®ç»“æ„'],
        associatedNotesCount: 2,
        isAutoGenerated: true,
        level: 1
      },
      {
        id: 'test_child3',
        name: 'ç¼–ç¨‹è¯­è¨€',
        category: 'ç¬¬1å±‚',
        value: 70,
        symbolSize: 45,
        itemStyle: { color: '#51cf66' },
        label: { show: true },
        description: 'ç¼–ç¨‹è¯­è¨€å­¦ä¹ ',
        progress: 70,
        keywords: ['ç¼–ç¨‹', 'è¯­è¨€'],
        associatedNotesCount: 4,
        isAutoGenerated: false,
        level: 1
      },
      {
        id: 'test_grandchild1',
        name: 'æ’åºç®—æ³•',
        category: 'ç¬¬2å±‚',
        value: 30,
        symbolSize: 40,
        itemStyle: { color: '#74c0fc' },
        label: { show: true },
        description: 'å„ç§æ’åºç®—æ³•',
        progress: 30,
        keywords: ['æ’åº', 'ç®—æ³•'],
        associatedNotesCount: 1,
        isAutoGenerated: true,
        level: 2
      }
    ];

    const links: KnowledgeLink[] = [
      {
        source: 'test_root',
        target: 'test_child1',
        lineStyle: { color: '#999', width: 2.5 }
      },
      {
        source: 'test_root',
        target: 'test_child2',
        lineStyle: { color: '#999', width: 2.5 }
      },
      {
        source: 'test_root',
        target: 'test_child3',
        lineStyle: { color: '#999', width: 2.5 }
      },
      {
        source: 'test_child1',
        target: 'test_grandchild1',
        lineStyle: { color: '#999', width: 2 }
      }
    ];

    return { nodes, links };
  };

  // åˆå§‹åŒ–echarts
  const initChart = () => {
    if (!chartRef.current) {
      console.warn('âš ï¸ chartRef.current ä¸ºç©ºï¼Œæ— æ³•åˆå§‹åŒ–å›¾è¡¨');
      return;
    }

    console.log('ğŸ“Š å¼€å§‹åˆå§‹åŒ–echartsåŠ›å‘å›¾...');

    // é”€æ¯ä¹‹å‰çš„å›¾è¡¨å®ä¾‹
    if (chartInstanceRef.current) {
      chartInstanceRef.current.dispose();
    }

    // åˆ›å»ºæ–°çš„å›¾è¡¨å®ä¾‹
    const chart = echarts.init(chartRef.current);
    chartInstanceRef.current = chart;

    // æ·»åŠ æµ‹è¯•æ•°æ®
    const testData = createTestData();
    updateChart(testData.nodes, testData.links);

    // ç›‘å¬ç‚¹å‡»äº‹ä»¶
    chart.on('click', (params: any) => {
      if (params.dataType === 'node') {
        console.log('ğŸ–±ï¸ ç‚¹å‡»èŠ‚ç‚¹:', params.data.name);
        setSelectedNode(params.data);
        setShowNodeDetail(true);
      }
    });

    // ç›‘å¬çª—å£å¤§å°å˜åŒ–
    const handleResize = () => {
      chart.resize();
    };

    window.addEventListener('resize', handleResize);

    console.log('ğŸ“Š echartsåŠ›å‘å›¾åˆå§‹åŒ–å®Œæˆ');

    return () => {
      window.removeEventListener('resize', handleResize);
      chart.dispose();
    };
  };

  // æ›´æ–°å›¾è¡¨æ•°æ®
  const updateChart = (nodes: KnowledgeNode[], links: KnowledgeLink[]) => {
    if (!chartInstanceRef.current) {
      console.warn('âš ï¸ å›¾è¡¨å®ä¾‹ä¸å­˜åœ¨ï¼Œæ— æ³•æ›´æ–°æ•°æ®');
      return;
    }

    console.log('ğŸ“Š æ›´æ–°å›¾è¡¨æ•°æ®ï¼ŒèŠ‚ç‚¹æ•°é‡:', nodes.length, 'è¿æ¥æ•°é‡:', links.length);

    const option = {
      title: {
        text: 'çŸ¥è¯†åœ°å›¾',
        left: 'center',
        top: 20,
        textStyle: {
          color: '#333',
          fontSize: 18,
          fontWeight: 'bold'
        }
      },
      tooltip: {
        trigger: 'item',
        formatter: (params: any) => {
          if (params.dataType === 'node') {
            const data = params.data;
            return `
              <div style="padding: 10px;">
                <div style="font-weight: bold; margin-bottom: 5px;">${data.name}</div>
                <div>å±‚çº§: ${data.category}</div>
                <div>è¿›åº¦: ${data.progress || 0}%</div>
                <div>å…³è”ç¬”è®°: ${data.associatedNotesCount || 0} ç¯‡</div>
                <div>ç”Ÿæˆæ–¹å¼: ${data.isAutoGenerated ? 'AIè‡ªåŠ¨ç”Ÿæˆ' : 'æ‰‹åŠ¨åˆ›å»º'}</div>
              </div>
            `;
          }
          return '';
        }
      },
      legend: {
        show: false
      },
      series: [
        {
          name: 'çŸ¥è¯†åœ°å›¾',
          type: 'graph',
          layout: 'force',
          data: nodes,
          links: links,
          categories: [
            { name: 'ç¬¬0å±‚' },
            { name: 'ç¬¬1å±‚' },
            { name: 'ç¬¬2å±‚' },
            { name: 'ç¬¬3å±‚' },
            { name: 'ç¬¬4å±‚' },
            { name: 'ç¬¬5å±‚' }
          ],
          roam: true, // å…è®¸ç¼©æ”¾å’Œå¹³ç§»
          focusNodeAdjacency: true, // é¼ æ ‡æ‚¬åœæ—¶é«˜äº®ç›¸é‚»èŠ‚ç‚¹
          draggable: true, // å…è®¸æ‹–æ‹½èŠ‚ç‚¹
          symbol: 'circle',
          symbolSize: (value: any, params: any) => {
            return params.data.symbolSize;
          },
          label: {
            show: true,
            position: 'inside',
            fontSize: 12,
            fontWeight: 'bold',
            color: '#fff',
            formatter: (params: any) => {
              // æ ¹æ®èŠ‚ç‚¹å¤§å°è°ƒæ•´æ–‡å­—æ˜¾ç¤º
              if (params.data.symbolSize > 50) {
                return params.data.name;
              } else if (params.data.symbolSize > 35) {
                return params.data.name.length > 4 ? params.data.name.substring(0, 4) + '...' : params.data.name;
              } else {
                return params.data.name.length > 2 ? params.data.name.substring(0, 2) + '...' : params.data.name;
              }
            }
          },
          edgeSymbol: ['none', 'arrow'],
          edgeSymbolSize: [0, 8],
          force: {
            repulsion: 1000, // èŠ‚ç‚¹é—´æ–¥åŠ›
            gravity: 0.1, // å‘å¿ƒåŠ›
            edgeLength: [100, 200], // è¾¹é•¿åº¦
            layoutAnimation: true
          },
          lineStyle: {
            color: 'source',
            curveness: 0.1,
            opacity: 0.6
          },
          emphasis: {
            focus: 'adjacency',
            lineStyle: {
              width: 3
            }
          }
        }
      ]
    };

    chartInstanceRef.current.setOption(option, true);
    console.log('âœ… å›¾è¡¨æ•°æ®æ›´æ–°å®Œæˆ');
  };

  // åŠ è½½çŸ¥è¯†æ ‘æ•°æ®
  const loadTreeData = async () => {
    if (!currentTreeId) {
      console.warn('âš ï¸ æ²¡æœ‰å¯ç”¨çš„çŸ¥è¯†æ ‘ID');
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      console.log('ğŸ“Š å¼€å§‹åŠ è½½çŸ¥è¯†æ ‘æ•°æ®ï¼Œæ ‘ID:', currentTreeId);
      
      const response = await knowledgeTreeApi.getTreeData(currentTreeId, true);
      
      console.log('ğŸ“Š çŸ¥è¯†æ ‘æ•°æ®å“åº”:', response);
      
      if (response.data && response.data.tree) {
        console.log('âœ… çŸ¥è¯†æ ‘æ•°æ®åŠ è½½æˆåŠŸ:', response.data);
        
        // è½¬æ¢æ•°æ®
        const forceData = convertToForceData(response.data.tree);
        console.log('ğŸ”„ è½¬æ¢åçš„åŠ›å‘å›¾æ•°æ®:', forceData);

        // æ›´æ–°å›¾è¡¨
        updateChart(forceData.nodes, forceData.links);
      } else {
        console.warn('âš ï¸ çŸ¥è¯†æ ‘æ•°æ®åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨æµ‹è¯•æ•°æ®');
        // å¦‚æœAPIæ•°æ®åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨æµ‹è¯•æ•°æ®
        const testData = createTestData();
        updateChart(testData.nodes, testData.links);
      }
    } catch (error) {
      console.error('âŒ åŠ è½½çŸ¥è¯†æ ‘æ•°æ®å¤±è´¥:', error);
      // å‡ºé”™æ—¶ä½¿ç”¨æµ‹è¯•æ•°æ®
      const testData = createTestData();
      updateChart(testData.nodes, testData.links);
    } finally {
      setLoading(false);
    }
  };

  // ç»„ä»¶æŒ‚è½½æ—¶åˆå§‹åŒ–
  useEffect(() => {
    console.log('ğŸš€ çŸ¥è¯†åœ°å›¾ç»„ä»¶æŒ‚è½½ï¼Œå¼€å§‹åˆå§‹åŒ–...');
    loadTreeList();
  }, []);

  // å½“è·å–åˆ°çŸ¥è¯†æ ‘IDåï¼Œåˆå§‹åŒ–å›¾è¡¨å¹¶åŠ è½½æ•°æ®
  useEffect(() => {
    if (currentTreeId && !treeListLoading) {
      console.log('ğŸ¯ è§¦å‘åˆå§‹åŒ–å›¾è¡¨ï¼ŒcurrentTreeId:', currentTreeId, 'treeListLoading:', treeListLoading);
      
      // åˆå§‹åŒ–å›¾è¡¨
      const cleanup = initChart();
      
      // å»¶è¿ŸåŠ è½½æ•°æ®ï¼Œç¡®ä¿å›¾è¡¨åˆå§‹åŒ–å®Œæˆ
      setTimeout(() => {
        loadTreeData();
      }, 100);

      return cleanup;
    }
  }, [currentTreeId, treeListLoading]);

  // æ¸…ç†å‡½æ•°
  useEffect(() => {
    return () => {
      console.log('ğŸ§¹ çŸ¥è¯†åœ°å›¾ç»„ä»¶å¸è½½ï¼Œæ¸…ç†èµ„æº...');
      if (chartInstanceRef.current) {
        chartInstanceRef.current.dispose();
      }
    };
  }, []);

  // å…³é—­è¯¦æƒ…é¢æ¿
  const closeNodeDetail = () => {
    setShowNodeDetail(false);
    setSelectedNode(null);
  };

  // é‡ç½®åœ°å›¾ä½ç½®
  const resetMapPosition = () => {
    if (chartInstanceRef.current) {
      // é‡ç½®ç¼©æ”¾å’Œå¹³ç§»
      chartInstanceRef.current.dispatchAction({
        type: 'restore'
      });
    }
  };

  if (loading || treeListLoading) {
    return (
      <div className="knowledge-map-container">
        <div className="loading-state">
          <div className="spinner"></div>
          <div>åŠ è½½çŸ¥è¯†åœ°å›¾...</div>
        </div>
      </div>
    );
  }

  return (
    <div className="knowledge-map-container">
      {/* åœ°å›¾åŒºåŸŸ */}
      <div className="map-container">
        <div 
          ref={chartRef} 
          className="knowledge-map-chart"
          style={{ width: '100%', height: '100%' }}
        />

        {/* åœ°å›¾æ§åˆ¶æŒ‰é’® */}
        <div className="map-controls">
          <button className="control-btn reset" onClick={resetMapPosition} title="é‡ç½®è§†å›¾">
            â†º
          </button>
        </div>
      </div>

      {/* çŸ¥è¯†ç‚¹è¯¦æƒ…å¼¹çª— */}
      <div className={`node-detail ${showNodeDetail ? 'show' : ''}`}>
        <div className="drag-handle"></div>
        <div className="node-header">
          <h2>{selectedNode?.name}</h2>
          <button className="detail-close" onClick={closeNodeDetail}>
            Ã—
          </button>
        </div>
        <p>{selectedNode?.description}</p>
        
        <div className="progress-box">
          <h4>å­¦ä¹ è¿›åº¦</h4>
          <div className="progress mt-8">
            <div 
              className="progress-bar" 
              style={{ width: `${selectedNode?.progress || 0}%` }}
            ></div>
          </div>
          <p className="text-sm mt-8">
            æ™ºæ…§å€¼ï¼š{selectedNode?.progress || 0}/100
          </p>
        </div>

        <div className="node-details-info">
          <div className="info-item">
            <span className="info-label">å±‚çº§:</span>
            <span className="info-value">{selectedNode?.category}</span>
          </div>
          <div className="info-item">
            <span className="info-label">å…³è”ç¬”è®°:</span>
            <span className="info-value">{selectedNode?.associatedNotesCount || 0} ç¯‡</span>
          </div>
          <div className="info-item">
            <span className="info-label">ç”Ÿæˆæ–¹å¼:</span>
            <span className="info-value">{selectedNode?.isAutoGenerated ? 'AIè‡ªåŠ¨ç”Ÿæˆ' : 'æ‰‹åŠ¨åˆ›å»º'}</span>
          </div>
        </div>

        {selectedNode?.keywords && selectedNode.keywords.length > 0 && (
          <div className="node-keywords">
            <div className="keywords-label">å…³é”®è¯:</div>
            <div className="keywords-list">
              {selectedNode.keywords.map((keyword: string, index: number) => (
                <span key={index} className="keyword-tag">{keyword}</span>
              ))}
            </div>
          </div>
        )}
        
        <div className="action-buttons">
          <button className="btn btn-primary">å¤ä¹ </button>
          <button className="btn btn-outline">ç¬”è®°</button>
          <button className="btn btn-outline">æ¢ç´¢</button>
        </div>
      </div>
    </div>
  );
};

export default KnowledgeMap;

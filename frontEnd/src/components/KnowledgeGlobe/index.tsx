import React, { useState, useEffect, useRef } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three-stdlib';
import { knowledgeTreeApi } from '../../api/index';
import './index.css';

interface Node3D {
  id: string;
  name: string;
  category: string;
  progress: number;
  description: string;
  position: THREE.Vector3;
  mesh?: THREE.Mesh;
  level: number;
  children: Node3D[];
  parent?: Node3D;
  nodeId?: string;
  keywords?: string[];
  associatedNotesCount?: number;
  isAutoGenerated?: boolean;
}

const KnowledgeGlobe: React.FC = () => {
  const mountRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const controlsRef = useRef<OrbitControls | null>(null);
  const frameIdRef = useRef<number | null>(null);
  const nodesRef = useRef<Node3D[]>([]);
  const raycasterRef = useRef<THREE.Raycaster>(new THREE.Raycaster());
  const mouseRef = useRef<THREE.Vector2>(new THREE.Vector2());
  
  const [selectedNode, setSelectedNode] = useState<Node3D | null>(null);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [currentTreeId, setCurrentTreeId] = useState<number | null>(null);
  const [treeListLoading, setTreeListLoading] = useState(true);

  // 获取层级颜色 - 亮色调版本，在黑色背景下更醒目
  const getColorByLevel = (level: number, isAutoGenerated: boolean = false): number => {
    const colors = [
      0xff6b6b,  // 根节点 - 亮红色
      0x51cf66,  // 第一层 - 亮绿色
      0x74c0fc,  // 第二层 - 亮蓝色
      0xffd43b,  // 第三层 - 亮黄色
      0xda77f2,  // 第四层 - 亮紫色
      0x22d3ee,  // 第五层 - 亮青色
    ];
    
    let color = colors[level % colors.length];
    
    // AI自动生成的节点使用稍微暗一些的颜色
    if (isAutoGenerated) {
      // 将颜色值减少一些亮度
      const r = (color >> 16) & 0xff;
      const g = (color >> 8) & 0xff;
      const b = color & 0xff;
      color = ((r * 0.7) << 16) | ((g * 0.7) << 8) | (b * 0.7);
    }
    
    return color;
  };

  // 创建测试节点
  const createTestNodes = (): Node3D[] => {
    console.log('🧪 创建测试节点');
    const testNodes: Node3D[] = [
      {
        id: 'test_root',
        name: '测试根节点',
        category: '第0层',
        progress: 80,
        description: '这是一个测试根节点',
        position: new THREE.Vector3(0, 0, 0),
        level: 0,
        children: [],
        keywords: ['测试', '根节点'],
        associatedNotesCount: 5,
        isAutoGenerated: false
      },
      {
        id: 'test_child1',
        name: '测试子节点1',
        category: '第1层',
        progress: 60,
        description: '这是第一个测试子节点',
        position: new THREE.Vector3(5, 0, 0),
        level: 1,
        children: [],
        keywords: ['测试', '子节点'],
        associatedNotesCount: 3,
        isAutoGenerated: false
      },
      {
        id: 'test_child2',
        name: '测试子节点2',
        category: '第1层',
        progress: 40,
        description: '这是第二个测试子节点',
        position: new THREE.Vector3(-5, 0, 0),
        level: 1,
        children: [],
        keywords: ['测试', '子节点'],
        associatedNotesCount: 2,
        isAutoGenerated: true
      },
      {
        id: 'test_child3',
        name: '测试子节点3',
        category: '第1层',
        progress: 70,
        description: '这是第三个测试子节点',
        position: new THREE.Vector3(0, 5, 0),
        level: 1,
        children: [],
        keywords: ['测试', '子节点'],
        associatedNotesCount: 4,
        isAutoGenerated: false
      },
      {
        id: 'test_child4',
        name: '测试子节点4',
        category: '第1层',
        progress: 30,
        description: '这是第四个测试子节点',
        position: new THREE.Vector3(0, -5, 0),
        level: 1,
        children: [],
        keywords: ['测试', '子节点'],
        associatedNotesCount: 1,
        isAutoGenerated: true
      }
    ];
    
    console.log('🧪 测试节点创建完成:', testNodes);
    return testNodes;
  };

  // 将树形数据转换为3D节点
  const convertToNodes3D = (node: any, level: number = 0, parent?: Node3D): Node3D[] => {
    const nodes: Node3D[] = [];
    
    const node3D: Node3D = {
      id: node.nodeId || `${level}_${node.name}`,
      name: node.name || '未命名节点',
      category: `第${level}层`,
      progress: node.progress || 0,
      description: node.description || '',
      position: new THREE.Vector3(),
      level,
      children: [],
      parent,
      nodeId: node.nodeId,
      keywords: node.keywords || [],
      associatedNotesCount: node.associatedNotesCount || 0,
      isAutoGenerated: node.isAutoGenerated || false
    };

    nodes.push(node3D);

    if (node.children && node.children.length > 0) {
      node.children.forEach((child: any) => {
        const childNodes = convertToNodes3D(child, level + 1, node3D);
        node3D.children.push(...childNodes);
        nodes.push(...childNodes);
      });
    }

    return nodes;
  };

  // 计算3D球面位置 - 真正的球面分布
  const calculateSpherePositions = (nodes: Node3D[]) => {
    const levels = new Map<number, Node3D[]>();
    
    // 按层级分组
    nodes.forEach(node => {
      if (!levels.has(node.level)) {
        levels.set(node.level, []);
      }
      levels.get(node.level)!.push(node);
    });

    // 为每个层级分配球面位置
    levels.forEach((levelNodes, level) => {
      const radius = 3 + level * 2.5; // 根据层级调整半径
      const count = levelNodes.length;
      
      levelNodes.forEach((node, index) => {
        if (level === 0) {
          // 根节点在中心
          node.position.set(0, 0, 0);
        } else {
          // 使用球面坐标分布
          const phi = Math.acos(-1 + (2 * index) / count);
          const theta = Math.sqrt(count * Math.PI) * phi;
          
          const x = radius * Math.cos(theta) * Math.sin(phi);
          const y = radius * Math.sin(theta) * Math.sin(phi);
          const z = radius * Math.cos(phi);
          
          node.position.set(x, y, z);
        }
      });
    });
  };

  // 创建节点网格
  const createNodeMesh = (node: Node3D): THREE.Mesh => {
    const size = node.level === 0 ? 1.2 : 0.8; // 根节点更大
    const geometry = new THREE.SphereGeometry(size, 16, 16);
    
    const color = getColorByLevel(node.level, node.isAutoGenerated);
    
    const material = new THREE.MeshBasicMaterial({
      color: color,
      transparent: false
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.copy(node.position);
    mesh.userData = { node };

    console.log(`🎯 创建节点网格: ${node.name}, 位置: (${node.position.x.toFixed(2)}, ${node.position.y.toFixed(2)}, ${node.position.z.toFixed(2)}), 颜色: #${color.toString(16)}`);

    return mesh;
  };

  // 创建连接线
  const createConnections = (nodes: Node3D[]): THREE.Group => {
    const group = new THREE.Group();
    
    nodes.forEach(node => {
      if (node.parent) {
        const geometry = new THREE.BufferGeometry().setFromPoints([
          node.parent.position,
          node.position
        ]);
        
        const material = new THREE.LineBasicMaterial({
          color: 0x444444,
          transparent: true,
          opacity: 0.3
        });
        
        const line = new THREE.Line(geometry, material);
        group.add(line);
      }
    });

    console.log(`🔗 创建连接线数量: ${group.children.length}`);
    return group;
  };

  // 获取知识树列表并设置当前树ID
  const loadTreeList = async () => {
    try {
      setTreeListLoading(true);
      console.log('🌳 开始获取知识树列表...');
      const response = await knowledgeTreeApi.getTreeList();
      
      console.log('🌳 知识树列表响应:', response);
      
      if (response.data && Array.isArray(response.data) && response.data.length > 0) {
        // 使用第一个知识树的ID
        const firstTree = response.data[0];
        // @ts-ignore
        setCurrentTreeId(firstTree.treeIdStr);
        console.log('🌳 获取到知识树列表，使用第一个树ID:', firstTree.treeIdStr, '树名称:', firstTree.name);
      } else {
        console.warn('⚠️ 没有找到可用的知识树，响应数据:', response);
        setCurrentTreeId(null);
      }
    } catch (error) {
      console.error('❌ 获取知识树列表失败:', error);
      // 如果获取失败，回退到默认值
      console.log('🔄 回退到默认树ID: 1');
      setCurrentTreeId(1);
    } finally {
      setTreeListLoading(false);
    }
  };

  // 初始化3D场景
  const initScene = () => {
    if (!mountRef.current) {
      console.warn('⚠️ mountRef.current 为空，无法初始化场景');
      return;
    }

    console.log('🎬 开始初始化3D场景...');

    // 清理之前的渲染器
    if (rendererRef.current && mountRef.current.contains(rendererRef.current.domElement)) {
      mountRef.current.removeChild(rendererRef.current.domElement);
    }

    // 场景
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000011); // 深蓝色背景
    sceneRef.current = scene;
    console.log('🎬 场景创建完成');

    // 相机
    const camera = new THREE.PerspectiveCamera(
      75,
      mountRef.current.clientWidth / mountRef.current.clientHeight,
      0.1,
      1000
    );
    
    camera.position.set(0, 0, 15); // 初始相机位置
    cameraRef.current = camera;
    console.log('📷 相机创建完成，位置:', camera.position);

    // 渲染器
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    renderer.setClearColor(0x000011);
    mountRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;
    console.log('🖥️ 渲染器创建完成，尺寸:', mountRef.current.clientWidth, 'x', mountRef.current.clientHeight);

    // 创建OrbitControls控制器
    const controls = new OrbitControls(camera, renderer.domElement);
    
    // 控制器配置
    controls.enableDamping = true; // 启用阻尼（惯性）
    controls.dampingFactor = 0.05; // 阻尼系数
    controls.screenSpacePanning = false; // 禁用屏幕空间平移
    
    // 缩放限制
    controls.minDistance = 5; // 最小缩放距离
    controls.maxDistance = 50; // 最大缩放距离
    
    // 旋转限制
    controls.maxPolarAngle = Math.PI; // 允许完全旋转
    
    // 自动旋转
    controls.autoRotate = true; // 启用自动旋转
    controls.autoRotateSpeed = 0.5; // 自动旋转速度
    
    controlsRef.current = controls;
    console.log('🎮 控制器创建完成');

    // 强光照
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambientLight);
    console.log('💡 光照添加完成');

    // 添加测试节点
    console.log('🧪 添加测试节点...');
    const testNodes = createTestNodes();
    testNodes.forEach((node) => {
      const mesh = createNodeMesh(node);
      node.mesh = mesh;
      scene.add(mesh);
    });
    nodesRef.current = testNodes;
    console.log('🧪 测试节点添加完成，场景中对象数量:', scene.children.length);

    // 鼠标事件
    const handleClick = (event: MouseEvent) => {
      const rect = renderer.domElement.getBoundingClientRect();
      mouseRef.current.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouseRef.current.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycasterRef.current.setFromCamera(mouseRef.current, camera);
      const intersects = raycasterRef.current.intersectObjects(scene.children, true);
      
      if (intersects.length > 0) {
        const intersected = intersects[0].object as THREE.Mesh;
        if (intersected.userData?.node) {
          console.log('🖱️ 点击节点:', intersected.userData.node.name);
          setSelectedNode(intersected.userData.node);
        }
      } else {
        setSelectedNode(null);
      }
    };

    renderer.domElement.addEventListener('click', handleClick);

    // 动画循环
    const animate = () => {
      frameIdRef.current = requestAnimationFrame(animate);
      
      // 更新控制器（必须在每帧调用）
      controls.update();
      
      renderer.render(scene, camera);
    };

    animate();
    console.log('🎬 动画循环启动');

    // 窗口大小调整
    const handleResize = () => {
      if (!mountRef.current) return;
      
      camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    };

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      renderer.domElement.removeEventListener('click', handleClick);
      controls.dispose(); // 清理控制器
    };
  };

  // 添加节点到场景
  const addNodesToScene = (nodes: Node3D[]) => {
    if (!sceneRef.current) {
      console.warn('⚠️ sceneRef.current 为空，无法添加节点');
      return;
    }

    console.log('🎯 开始添加节点到场景，节点数量:', nodes.length);

    // 清理之前的节点（保留光照）
    const objectsToRemove: THREE.Object3D[] = [];
    sceneRef.current.traverse((child) => {
      if (child.userData?.node || child.type === 'Line' || child.type === 'Group') {
        objectsToRemove.push(child);
      }
    });
    objectsToRemove.forEach(obj => sceneRef.current!.remove(obj));
    console.log('🧹 清理了', objectsToRemove.length, '个旧对象');

    // 添加所有节点
    nodes.forEach((node) => {
      const mesh = createNodeMesh(node);
      node.mesh = mesh;
      sceneRef.current!.add(mesh);
    });

    // 添加连接线
    const connections = createConnections(nodes);
    sceneRef.current.add(connections);

    console.log('✅ 节点添加完成，场景中对象数量:', sceneRef.current.children.length);
  };

  // 加载知识树数据
  const loadTreeData = async () => {
    if (!currentTreeId) {
      console.warn('⚠️ 没有可用的知识树ID');
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      console.log('📊 开始加载知识树数据，树ID:', currentTreeId);
      
      const response = await knowledgeTreeApi.getTreeData(currentTreeId, true);
      
      console.log('📊 知识树数据响应:', response);
      
      if (response.data && response.data.tree) {
        console.log('✅ 知识树数据加载成功:', response.data);
        
        // 转换数据
        const allNodes = convertToNodes3D(response.data.tree);
        console.log('🔄 转换后的节点数据:', allNodes);

        // 计算位置
        calculateSpherePositions(allNodes);
        nodesRef.current = allNodes;

        // 添加节点到场景
        addNodesToScene(allNodes);
      } else {
        console.warn('⚠️ 知识树数据加载失败，使用测试数据');
        // 如果API数据加载失败，使用测试数据
        const testNodes = createTestNodes();
        nodesRef.current = testNodes;
        addNodesToScene(testNodes);
      }
    } catch (error) {
      console.error('❌ 加载知识树数据失败:', error);
      // 出错时使用测试数据
      const testNodes = createTestNodes();
      nodesRef.current = testNodes;
      addNodesToScene(testNodes);
    } finally {
      setLoading(false);
    }
  };

  // 组件挂载时初始化
  useEffect(() => {
    console.log('🚀 组件挂载，开始初始化...');
    loadTreeList();
  }, []);

  // 当获取到知识树ID后，加载知识树数据
  useEffect(() => {
    if (currentTreeId && !treeListLoading) {
      console.log('🎯 触发加载知识树数据，currentTreeId:', currentTreeId, 'treeListLoading:', treeListLoading);
      
      // 初始化场景
      const cleanup = initScene();
      
      // 延迟加载数据，确保场景初始化完成
      setTimeout(() => {
        loadTreeData();
      }, 100);

      return cleanup;
    }
  }, [currentTreeId, treeListLoading]);

  // 清理函数
  useEffect(() => {
    return () => {
      console.log('🧹 组件卸载，清理资源...');
      if (frameIdRef.current) {
        cancelAnimationFrame(frameIdRef.current);
      }
      if (rendererRef.current && mountRef.current && mountRef.current.contains(rendererRef.current.domElement)) {
        mountRef.current.removeChild(rendererRef.current.domElement);
      }
    };
  }, []);

  // 搜索功能
  const handleSearch = (term: string) => {
    setSearchTerm(term);
    
    if (!sceneRef.current) return;

    nodesRef.current.forEach(node => {
      if (node.mesh) {
        const material = node.mesh.material as THREE.MeshBasicMaterial;
        const isMatch = term && node.name.toLowerCase().includes(term.toLowerCase());
        
        if (isMatch) {
          material.color.setHex(0xffffff); // 白色高亮
          node.mesh.scale.setScalar(1.5);
        } else {
          material.color.setHex(getColorByLevel(node.level, node.isAutoGenerated));
          node.mesh.scale.setScalar(1);
        }
      }
    });
  };

  // 重置视角
  const resetCamera = () => {
    if (controlsRef.current && cameraRef.current) {
      // 重置相机位置
      cameraRef.current.position.set(0, 0, 15);
      controlsRef.current.target.set(0, 0, 0);
      controlsRef.current.update();
    }
  };

  // 切换自动旋转
  const toggleAutoRotate = () => {
    if (controlsRef.current) {
      controlsRef.current.autoRotate = !controlsRef.current.autoRotate;
    }
  };

  // 关闭节点详情
  const closeNodeDetails = () => {
    setSelectedNode(null);
  };

  if (loading || treeListLoading) {
    return (
      <div className="knowledge-globe-container">
        <div className="loading-state">
          <div className="spinner"></div>
          <div>加载3D知识球...</div>
        </div>
      </div>
    );
  }

  return (
    <div className="knowledge-globe-container">
      {/* 搜索栏 */}
      <div className="search-bar">
        <svg className="search-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M15.5 14H14.71L14.43 13.73C15.41 12.59 16 11.11 16 9.5C16 5.91 13.09 3 9.5 3C5.91 3 3 5.91 3 9.5C3 13.09 5.91 16 9.5 16C11.11 16 12.59 15.41 13.73 14.43L14 14.71V15.5L19 20.49L20.49 19L15.5 14ZM9.5 14C7.01 14 5 11.99 5 9.5C5 7.01 7.01 5 9.5 5C11.99 5 14 7.01 14 9.5C14 11.99 11.99 14 9.5 14Z" fill="currentColor"/>
        </svg>
        <input 
          type="text" 
          className="search-input" 
          placeholder="搜索知识点..." 
          value={searchTerm}
          onChange={(e) => handleSearch(e.target.value)}
        />
        {searchTerm && (
          <button 
            className="search-clear"
            onClick={() => handleSearch('')}
          >
            ×
          </button>
        )}
      </div>

      {/* 3D场景容器 */}
      <div className="globe-scene" ref={mountRef}></div>

      {/* 控制面板 */}
      <div className="controls-panel">
        <button className="control-btn" onClick={resetCamera} title="重置视角">
          🎯
        </button>
        <button className="control-btn" onClick={toggleAutoRotate} title="切换自动旋转">
          🔄
        </button>
      </div>

      {/* 控制提示 */}
      <div className="controls-hint">
        <div className="hint-item">🖱️ 拖拽旋转视角</div>
        <div className="hint-item">🔍 滚轮缩放场景</div>
        <div className="hint-item">🎯 点击重置视角</div>
        <div className="hint-item">🔄 切换自动旋转</div>
        <div className="hint-item">📊 节点数量: {nodesRef.current.length}</div>
        <div className="hint-item">🌈 按层级着色的知识节点</div>
      </div>

      {/* 节点详情面板 */}
      {selectedNode && (
        <div className="node-details show" onClick={(e) => e.stopPropagation()}>
          <div className="node-details-header">
            <h2 className="node-details-title">{selectedNode.name}</h2>
            <button className="node-details-close" onClick={closeNodeDetails}>×</button>
          </div>
          <div className="node-details-category">{selectedNode.category}</div>
          <p className="node-details-description">{selectedNode.description}</p>
          <div className="node-details-progress">
            <div className="progress-label">
              <span>学习进度</span>
              <span>{selectedNode.progress}%</span>
            </div>
            <div className="progress-bar">
              <div 
                className="progress-value" 
                style={{ width: `${selectedNode.progress}%` }}
              ></div>
            </div>
          </div>
          <div className="node-details-info">
            <div className="info-item">
              <span className="info-label">层级:</span>
              <span className="info-value">第 {selectedNode.level + 1} 层</span>
            </div>
            <div className="info-item">
              <span className="info-label">子节点:</span>
              <span className="info-value">{selectedNode.children.length} 个</span>
            </div>
            <div className="info-item">
              <span className="info-label">关联笔记:</span>
              <span className="info-value">{selectedNode.associatedNotesCount} 篇</span>
            </div>
            <div className="info-item">
              <span className="info-label">生成方式:</span>
              <span className="info-value">{selectedNode.isAutoGenerated ? 'AI自动生成' : '手动创建'}</span>
            </div>
          </div>
          {selectedNode.keywords && selectedNode.keywords.length > 0 && (
            <div className="node-keywords">
              <div className="keywords-label">关键词:</div>
              <div className="keywords-list">
                {selectedNode.keywords.map((keyword, index) => (
                  <span key={index} className="keyword-tag">{keyword}</span>
                ))}
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default KnowledgeGlobe;

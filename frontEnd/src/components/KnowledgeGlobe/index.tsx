import React, { useState, useEffect, useRef } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three-stdlib';
import { knowledgeTreeApi } from '../../api/index';
import './index.css';

interface Node3D {
  id: string;
  name: string;
  category: string;
  progress: number;
  description: string;
  position: THREE.Vector3;
  mesh?: THREE.Mesh;
  level: number;
  children: Node3D[];
  parent?: Node3D;
  nodeId?: string;
  keywords?: string[];
  associatedNotesCount?: number;
  isAutoGenerated?: boolean;
}

const KnowledgeGlobe: React.FC = () => {
  const mountRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const controlsRef = useRef<OrbitControls | null>(null);
  const frameIdRef = useRef<number | null>(null);
  const nodesRef = useRef<Node3D[]>([]);
  const raycasterRef = useRef<THREE.Raycaster>(new THREE.Raycaster());
  const mouseRef = useRef<THREE.Vector2>(new THREE.Vector2());
  
  const [selectedNode, setSelectedNode] = useState<Node3D | null>(null);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [currentTreeId, setCurrentTreeId] = useState<number | null>(null);
  const [treeListLoading, setTreeListLoading] = useState(true);

  // è·å–å±‚çº§é¢œè‰² - äº®è‰²è°ƒç‰ˆæœ¬ï¼Œåœ¨é»‘è‰²èƒŒæ™¯ä¸‹æ›´é†’ç›®
  const getColorByLevel = (level: number, isAutoGenerated: boolean = false): number => {
    const colors = [
      0xff6b6b,  // æ ¹èŠ‚ç‚¹ - äº®çº¢è‰²
      0x51cf66,  // ç¬¬ä¸€å±‚ - äº®ç»¿è‰²
      0x74c0fc,  // ç¬¬äºŒå±‚ - äº®è“è‰²
      0xffd43b,  // ç¬¬ä¸‰å±‚ - äº®é»„è‰²
      0xda77f2,  // ç¬¬å››å±‚ - äº®ç´«è‰²
      0x22d3ee,  // ç¬¬äº”å±‚ - äº®é’è‰²
    ];
    
    let color = colors[level % colors.length];
    
    // AIè‡ªåŠ¨ç”Ÿæˆçš„èŠ‚ç‚¹ä½¿ç”¨ç¨å¾®æš—ä¸€äº›çš„é¢œè‰²
    if (isAutoGenerated) {
      // å°†é¢œè‰²å€¼å‡å°‘ä¸€äº›äº®åº¦
      const r = (color >> 16) & 0xff;
      const g = (color >> 8) & 0xff;
      const b = color & 0xff;
      color = ((r * 0.7) << 16) | ((g * 0.7) << 8) | (b * 0.7);
    }
    
    return color;
  };

  // åˆ›å»ºæµ‹è¯•èŠ‚ç‚¹
  const createTestNodes = (): Node3D[] => {
    console.log('ğŸ§ª åˆ›å»ºæµ‹è¯•èŠ‚ç‚¹');
    const testNodes: Node3D[] = [
      {
        id: 'test_root',
        name: 'æµ‹è¯•æ ¹èŠ‚ç‚¹',
        category: 'ç¬¬0å±‚',
        progress: 80,
        description: 'è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æ ¹èŠ‚ç‚¹',
        position: new THREE.Vector3(0, 0, 0),
        level: 0,
        children: [],
        keywords: ['æµ‹è¯•', 'æ ¹èŠ‚ç‚¹'],
        associatedNotesCount: 5,
        isAutoGenerated: false
      },
      {
        id: 'test_child1',
        name: 'æµ‹è¯•å­èŠ‚ç‚¹1',
        category: 'ç¬¬1å±‚',
        progress: 60,
        description: 'è¿™æ˜¯ç¬¬ä¸€ä¸ªæµ‹è¯•å­èŠ‚ç‚¹',
        position: new THREE.Vector3(5, 0, 0),
        level: 1,
        children: [],
        keywords: ['æµ‹è¯•', 'å­èŠ‚ç‚¹'],
        associatedNotesCount: 3,
        isAutoGenerated: false
      },
      {
        id: 'test_child2',
        name: 'æµ‹è¯•å­èŠ‚ç‚¹2',
        category: 'ç¬¬1å±‚',
        progress: 40,
        description: 'è¿™æ˜¯ç¬¬äºŒä¸ªæµ‹è¯•å­èŠ‚ç‚¹',
        position: new THREE.Vector3(-5, 0, 0),
        level: 1,
        children: [],
        keywords: ['æµ‹è¯•', 'å­èŠ‚ç‚¹'],
        associatedNotesCount: 2,
        isAutoGenerated: true
      },
      {
        id: 'test_child3',
        name: 'æµ‹è¯•å­èŠ‚ç‚¹3',
        category: 'ç¬¬1å±‚',
        progress: 70,
        description: 'è¿™æ˜¯ç¬¬ä¸‰ä¸ªæµ‹è¯•å­èŠ‚ç‚¹',
        position: new THREE.Vector3(0, 5, 0),
        level: 1,
        children: [],
        keywords: ['æµ‹è¯•', 'å­èŠ‚ç‚¹'],
        associatedNotesCount: 4,
        isAutoGenerated: false
      },
      {
        id: 'test_child4',
        name: 'æµ‹è¯•å­èŠ‚ç‚¹4',
        category: 'ç¬¬1å±‚',
        progress: 30,
        description: 'è¿™æ˜¯ç¬¬å››ä¸ªæµ‹è¯•å­èŠ‚ç‚¹',
        position: new THREE.Vector3(0, -5, 0),
        level: 1,
        children: [],
        keywords: ['æµ‹è¯•', 'å­èŠ‚ç‚¹'],
        associatedNotesCount: 1,
        isAutoGenerated: true
      }
    ];
    
    console.log('ğŸ§ª æµ‹è¯•èŠ‚ç‚¹åˆ›å»ºå®Œæˆ:', testNodes);
    return testNodes;
  };

  // å°†æ ‘å½¢æ•°æ®è½¬æ¢ä¸º3DèŠ‚ç‚¹
  const convertToNodes3D = (node: any, level: number = 0, parent?: Node3D): Node3D[] => {
    const nodes: Node3D[] = [];
    
    const node3D: Node3D = {
      id: node.nodeId || `${level}_${node.name}`,
      name: node.name || 'æœªå‘½åèŠ‚ç‚¹',
      category: `ç¬¬${level}å±‚`,
      progress: node.progress || 0,
      description: node.description || '',
      position: new THREE.Vector3(),
      level,
      children: [],
      parent,
      nodeId: node.nodeId,
      keywords: node.keywords || [],
      associatedNotesCount: node.associatedNotesCount || 0,
      isAutoGenerated: node.isAutoGenerated || false
    };

    nodes.push(node3D);

    if (node.children && node.children.length > 0) {
      node.children.forEach((child: any) => {
        const childNodes = convertToNodes3D(child, level + 1, node3D);
        node3D.children.push(...childNodes);
        nodes.push(...childNodes);
      });
    }

    return nodes;
  };

  // è®¡ç®—3Dçƒé¢ä½ç½® - çœŸæ­£çš„çƒé¢åˆ†å¸ƒ
  const calculateSpherePositions = (nodes: Node3D[]) => {
    const levels = new Map<number, Node3D[]>();
    
    // æŒ‰å±‚çº§åˆ†ç»„
    nodes.forEach(node => {
      if (!levels.has(node.level)) {
        levels.set(node.level, []);
      }
      levels.get(node.level)!.push(node);
    });

    // ä¸ºæ¯ä¸ªå±‚çº§åˆ†é…çƒé¢ä½ç½®
    levels.forEach((levelNodes, level) => {
      const radius = 3 + level * 2.5; // æ ¹æ®å±‚çº§è°ƒæ•´åŠå¾„
      const count = levelNodes.length;
      
      levelNodes.forEach((node, index) => {
        if (level === 0) {
          // æ ¹èŠ‚ç‚¹åœ¨ä¸­å¿ƒ
          node.position.set(0, 0, 0);
        } else {
          // ä½¿ç”¨çƒé¢åæ ‡åˆ†å¸ƒ
          const phi = Math.acos(-1 + (2 * index) / count);
          const theta = Math.sqrt(count * Math.PI) * phi;
          
          const x = radius * Math.cos(theta) * Math.sin(phi);
          const y = radius * Math.sin(theta) * Math.sin(phi);
          const z = radius * Math.cos(phi);
          
          node.position.set(x, y, z);
        }
      });
    });
  };

  // åˆ›å»ºèŠ‚ç‚¹ç½‘æ ¼
  const createNodeMesh = (node: Node3D): THREE.Mesh => {
    const size = node.level === 0 ? 1.2 : 0.8; // æ ¹èŠ‚ç‚¹æ›´å¤§
    const geometry = new THREE.SphereGeometry(size, 16, 16);
    
    const color = getColorByLevel(node.level, node.isAutoGenerated);
    
    const material = new THREE.MeshBasicMaterial({
      color: color,
      transparent: false
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.copy(node.position);
    mesh.userData = { node };

    console.log(`ğŸ¯ åˆ›å»ºèŠ‚ç‚¹ç½‘æ ¼: ${node.name}, ä½ç½®: (${node.position.x.toFixed(2)}, ${node.position.y.toFixed(2)}, ${node.position.z.toFixed(2)}), é¢œè‰²: #${color.toString(16)}`);

    return mesh;
  };

  // åˆ›å»ºè¿æ¥çº¿
  const createConnections = (nodes: Node3D[]): THREE.Group => {
    const group = new THREE.Group();
    
    nodes.forEach(node => {
      if (node.parent) {
        const geometry = new THREE.BufferGeometry().setFromPoints([
          node.parent.position,
          node.position
        ]);
        
        const material = new THREE.LineBasicMaterial({
          color: 0x444444,
          transparent: true,
          opacity: 0.3
        });
        
        const line = new THREE.Line(geometry, material);
        group.add(line);
      }
    });

    console.log(`ğŸ”— åˆ›å»ºè¿æ¥çº¿æ•°é‡: ${group.children.length}`);
    return group;
  };

  // è·å–çŸ¥è¯†æ ‘åˆ—è¡¨å¹¶è®¾ç½®å½“å‰æ ‘ID
  const loadTreeList = async () => {
    try {
      setTreeListLoading(true);
      console.log('ğŸŒ³ å¼€å§‹è·å–çŸ¥è¯†æ ‘åˆ—è¡¨...');
      const response = await knowledgeTreeApi.getTreeList();
      
      console.log('ğŸŒ³ çŸ¥è¯†æ ‘åˆ—è¡¨å“åº”:', response);
      
      if (response.data && Array.isArray(response.data) && response.data.length > 0) {
        // ä½¿ç”¨ç¬¬ä¸€ä¸ªçŸ¥è¯†æ ‘çš„ID
        const firstTree = response.data[0];
        // @ts-ignore
        setCurrentTreeId(firstTree.treeIdStr);
        console.log('ğŸŒ³ è·å–åˆ°çŸ¥è¯†æ ‘åˆ—è¡¨ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªæ ‘ID:', firstTree.treeIdStr, 'æ ‘åç§°:', firstTree.name);
      } else {
        console.warn('âš ï¸ æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„çŸ¥è¯†æ ‘ï¼Œå“åº”æ•°æ®:', response);
        setCurrentTreeId(null);
      }
    } catch (error) {
      console.error('âŒ è·å–çŸ¥è¯†æ ‘åˆ—è¡¨å¤±è´¥:', error);
      // å¦‚æœè·å–å¤±è´¥ï¼Œå›é€€åˆ°é»˜è®¤å€¼
      console.log('ğŸ”„ å›é€€åˆ°é»˜è®¤æ ‘ID: 1');
      setCurrentTreeId(1);
    } finally {
      setTreeListLoading(false);
    }
  };

  // åˆå§‹åŒ–3Dåœºæ™¯
  const initScene = () => {
    if (!mountRef.current) {
      console.warn('âš ï¸ mountRef.current ä¸ºç©ºï¼Œæ— æ³•åˆå§‹åŒ–åœºæ™¯');
      return;
    }

    console.log('ğŸ¬ å¼€å§‹åˆå§‹åŒ–3Dåœºæ™¯...');

    // æ¸…ç†ä¹‹å‰çš„æ¸²æŸ“å™¨
    if (rendererRef.current && mountRef.current.contains(rendererRef.current.domElement)) {
      mountRef.current.removeChild(rendererRef.current.domElement);
    }

    // åœºæ™¯
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000011); // æ·±è“è‰²èƒŒæ™¯
    sceneRef.current = scene;
    console.log('ğŸ¬ åœºæ™¯åˆ›å»ºå®Œæˆ');

    // ç›¸æœº
    const camera = new THREE.PerspectiveCamera(
      75,
      mountRef.current.clientWidth / mountRef.current.clientHeight,
      0.1,
      1000
    );
    
    camera.position.set(0, 0, 15); // åˆå§‹ç›¸æœºä½ç½®
    cameraRef.current = camera;
    console.log('ğŸ“· ç›¸æœºåˆ›å»ºå®Œæˆï¼Œä½ç½®:', camera.position);

    // æ¸²æŸ“å™¨
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    renderer.setClearColor(0x000011);
    mountRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;
    console.log('ğŸ–¥ï¸ æ¸²æŸ“å™¨åˆ›å»ºå®Œæˆï¼Œå°ºå¯¸:', mountRef.current.clientWidth, 'x', mountRef.current.clientHeight);

    // åˆ›å»ºOrbitControlsæ§åˆ¶å™¨
    const controls = new OrbitControls(camera, renderer.domElement);
    
    // æ§åˆ¶å™¨é…ç½®
    controls.enableDamping = true; // å¯ç”¨é˜»å°¼ï¼ˆæƒ¯æ€§ï¼‰
    controls.dampingFactor = 0.05; // é˜»å°¼ç³»æ•°
    controls.screenSpacePanning = false; // ç¦ç”¨å±å¹•ç©ºé—´å¹³ç§»
    
    // ç¼©æ”¾é™åˆ¶
    controls.minDistance = 5; // æœ€å°ç¼©æ”¾è·ç¦»
    controls.maxDistance = 50; // æœ€å¤§ç¼©æ”¾è·ç¦»
    
    // æ—‹è½¬é™åˆ¶
    controls.maxPolarAngle = Math.PI; // å…è®¸å®Œå…¨æ—‹è½¬
    
    // è‡ªåŠ¨æ—‹è½¬
    controls.autoRotate = true; // å¯ç”¨è‡ªåŠ¨æ—‹è½¬
    controls.autoRotateSpeed = 0.5; // è‡ªåŠ¨æ—‹è½¬é€Ÿåº¦
    
    controlsRef.current = controls;
    console.log('ğŸ® æ§åˆ¶å™¨åˆ›å»ºå®Œæˆ');

    // å¼ºå…‰ç…§
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambientLight);
    console.log('ğŸ’¡ å…‰ç…§æ·»åŠ å®Œæˆ');

    // æ·»åŠ æµ‹è¯•èŠ‚ç‚¹
    console.log('ğŸ§ª æ·»åŠ æµ‹è¯•èŠ‚ç‚¹...');
    const testNodes = createTestNodes();
    testNodes.forEach((node) => {
      const mesh = createNodeMesh(node);
      node.mesh = mesh;
      scene.add(mesh);
    });
    nodesRef.current = testNodes;
    console.log('ğŸ§ª æµ‹è¯•èŠ‚ç‚¹æ·»åŠ å®Œæˆï¼Œåœºæ™¯ä¸­å¯¹è±¡æ•°é‡:', scene.children.length);

    // é¼ æ ‡äº‹ä»¶
    const handleClick = (event: MouseEvent) => {
      const rect = renderer.domElement.getBoundingClientRect();
      mouseRef.current.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouseRef.current.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycasterRef.current.setFromCamera(mouseRef.current, camera);
      const intersects = raycasterRef.current.intersectObjects(scene.children, true);
      
      if (intersects.length > 0) {
        const intersected = intersects[0].object as THREE.Mesh;
        if (intersected.userData?.node) {
          console.log('ğŸ–±ï¸ ç‚¹å‡»èŠ‚ç‚¹:', intersected.userData.node.name);
          setSelectedNode(intersected.userData.node);
        }
      } else {
        setSelectedNode(null);
      }
    };

    renderer.domElement.addEventListener('click', handleClick);

    // åŠ¨ç”»å¾ªç¯
    const animate = () => {
      frameIdRef.current = requestAnimationFrame(animate);
      
      // æ›´æ–°æ§åˆ¶å™¨ï¼ˆå¿…é¡»åœ¨æ¯å¸§è°ƒç”¨ï¼‰
      controls.update();
      
      renderer.render(scene, camera);
    };

    animate();
    console.log('ğŸ¬ åŠ¨ç”»å¾ªç¯å¯åŠ¨');

    // çª—å£å¤§å°è°ƒæ•´
    const handleResize = () => {
      if (!mountRef.current) return;
      
      camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    };

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      renderer.domElement.removeEventListener('click', handleClick);
      controls.dispose(); // æ¸…ç†æ§åˆ¶å™¨
    };
  };

  // æ·»åŠ èŠ‚ç‚¹åˆ°åœºæ™¯
  const addNodesToScene = (nodes: Node3D[]) => {
    if (!sceneRef.current) {
      console.warn('âš ï¸ sceneRef.current ä¸ºç©ºï¼Œæ— æ³•æ·»åŠ èŠ‚ç‚¹');
      return;
    }

    console.log('ğŸ¯ å¼€å§‹æ·»åŠ èŠ‚ç‚¹åˆ°åœºæ™¯ï¼ŒèŠ‚ç‚¹æ•°é‡:', nodes.length);

    // æ¸…ç†ä¹‹å‰çš„èŠ‚ç‚¹ï¼ˆä¿ç•™å…‰ç…§ï¼‰
    const objectsToRemove: THREE.Object3D[] = [];
    sceneRef.current.traverse((child) => {
      if (child.userData?.node || child.type === 'Line' || child.type === 'Group') {
        objectsToRemove.push(child);
      }
    });
    objectsToRemove.forEach(obj => sceneRef.current!.remove(obj));
    console.log('ğŸ§¹ æ¸…ç†äº†', objectsToRemove.length, 'ä¸ªæ—§å¯¹è±¡');

    // æ·»åŠ æ‰€æœ‰èŠ‚ç‚¹
    nodes.forEach((node) => {
      const mesh = createNodeMesh(node);
      node.mesh = mesh;
      sceneRef.current!.add(mesh);
    });

    // æ·»åŠ è¿æ¥çº¿
    const connections = createConnections(nodes);
    sceneRef.current.add(connections);

    console.log('âœ… èŠ‚ç‚¹æ·»åŠ å®Œæˆï¼Œåœºæ™¯ä¸­å¯¹è±¡æ•°é‡:', sceneRef.current.children.length);
  };

  // åŠ è½½çŸ¥è¯†æ ‘æ•°æ®
  const loadTreeData = async () => {
    if (!currentTreeId) {
      console.warn('âš ï¸ æ²¡æœ‰å¯ç”¨çš„çŸ¥è¯†æ ‘ID');
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      console.log('ğŸ“Š å¼€å§‹åŠ è½½çŸ¥è¯†æ ‘æ•°æ®ï¼Œæ ‘ID:', currentTreeId);
      
      const response = await knowledgeTreeApi.getTreeData(currentTreeId, true);
      
      console.log('ğŸ“Š çŸ¥è¯†æ ‘æ•°æ®å“åº”:', response);
      
      if (response.data && response.data.tree) {
        console.log('âœ… çŸ¥è¯†æ ‘æ•°æ®åŠ è½½æˆåŠŸ:', response.data);
        
        // è½¬æ¢æ•°æ®
        const allNodes = convertToNodes3D(response.data.tree);
        console.log('ğŸ”„ è½¬æ¢åçš„èŠ‚ç‚¹æ•°æ®:', allNodes);

        // è®¡ç®—ä½ç½®
        calculateSpherePositions(allNodes);
        nodesRef.current = allNodes;

        // æ·»åŠ èŠ‚ç‚¹åˆ°åœºæ™¯
        addNodesToScene(allNodes);
      } else {
        console.warn('âš ï¸ çŸ¥è¯†æ ‘æ•°æ®åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨æµ‹è¯•æ•°æ®');
        // å¦‚æœAPIæ•°æ®åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨æµ‹è¯•æ•°æ®
        const testNodes = createTestNodes();
        nodesRef.current = testNodes;
        addNodesToScene(testNodes);
      }
    } catch (error) {
      console.error('âŒ åŠ è½½çŸ¥è¯†æ ‘æ•°æ®å¤±è´¥:', error);
      // å‡ºé”™æ—¶ä½¿ç”¨æµ‹è¯•æ•°æ®
      const testNodes = createTestNodes();
      nodesRef.current = testNodes;
      addNodesToScene(testNodes);
    } finally {
      setLoading(false);
    }
  };

  // ç»„ä»¶æŒ‚è½½æ—¶åˆå§‹åŒ–
  useEffect(() => {
    console.log('ğŸš€ ç»„ä»¶æŒ‚è½½ï¼Œå¼€å§‹åˆå§‹åŒ–...');
    loadTreeList();
  }, []);

  // å½“è·å–åˆ°çŸ¥è¯†æ ‘IDåï¼ŒåŠ è½½çŸ¥è¯†æ ‘æ•°æ®
  useEffect(() => {
    if (currentTreeId && !treeListLoading) {
      console.log('ğŸ¯ è§¦å‘åŠ è½½çŸ¥è¯†æ ‘æ•°æ®ï¼ŒcurrentTreeId:', currentTreeId, 'treeListLoading:', treeListLoading);
      
      // åˆå§‹åŒ–åœºæ™¯
      const cleanup = initScene();
      
      // å»¶è¿ŸåŠ è½½æ•°æ®ï¼Œç¡®ä¿åœºæ™¯åˆå§‹åŒ–å®Œæˆ
      setTimeout(() => {
        loadTreeData();
      }, 100);

      return cleanup;
    }
  }, [currentTreeId, treeListLoading]);

  // æ¸…ç†å‡½æ•°
  useEffect(() => {
    return () => {
      console.log('ğŸ§¹ ç»„ä»¶å¸è½½ï¼Œæ¸…ç†èµ„æº...');
      if (frameIdRef.current) {
        cancelAnimationFrame(frameIdRef.current);
      }
      if (rendererRef.current && mountRef.current && mountRef.current.contains(rendererRef.current.domElement)) {
        mountRef.current.removeChild(rendererRef.current.domElement);
      }
    };
  }, []);

  // æœç´¢åŠŸèƒ½
  const handleSearch = (term: string) => {
    setSearchTerm(term);
    
    if (!sceneRef.current) return;

    nodesRef.current.forEach(node => {
      if (node.mesh) {
        const material = node.mesh.material as THREE.MeshBasicMaterial;
        const isMatch = term && node.name.toLowerCase().includes(term.toLowerCase());
        
        if (isMatch) {
          material.color.setHex(0xffffff); // ç™½è‰²é«˜äº®
          node.mesh.scale.setScalar(1.5);
        } else {
          material.color.setHex(getColorByLevel(node.level, node.isAutoGenerated));
          node.mesh.scale.setScalar(1);
        }
      }
    });
  };

  // é‡ç½®è§†è§’
  const resetCamera = () => {
    if (controlsRef.current && cameraRef.current) {
      // é‡ç½®ç›¸æœºä½ç½®
      cameraRef.current.position.set(0, 0, 15);
      controlsRef.current.target.set(0, 0, 0);
      controlsRef.current.update();
    }
  };

  // åˆ‡æ¢è‡ªåŠ¨æ—‹è½¬
  const toggleAutoRotate = () => {
    if (controlsRef.current) {
      controlsRef.current.autoRotate = !controlsRef.current.autoRotate;
    }
  };

  // å…³é—­èŠ‚ç‚¹è¯¦æƒ…
  const closeNodeDetails = () => {
    setSelectedNode(null);
  };

  if (loading || treeListLoading) {
    return (
      <div className="knowledge-globe-container">
        <div className="loading-state">
          <div className="spinner"></div>
          <div>åŠ è½½3DçŸ¥è¯†çƒ...</div>
        </div>
      </div>
    );
  }

  return (
    <div className="knowledge-globe-container">
      {/* æœç´¢æ  */}
      <div className="search-bar">
        <svg className="search-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M15.5 14H14.71L14.43 13.73C15.41 12.59 16 11.11 16 9.5C16 5.91 13.09 3 9.5 3C5.91 3 3 5.91 3 9.5C3 13.09 5.91 16 9.5 16C11.11 16 12.59 15.41 13.73 14.43L14 14.71V15.5L19 20.49L20.49 19L15.5 14ZM9.5 14C7.01 14 5 11.99 5 9.5C5 7.01 7.01 5 9.5 5C11.99 5 14 7.01 14 9.5C14 11.99 11.99 14 9.5 14Z" fill="currentColor"/>
        </svg>
        <input 
          type="text" 
          className="search-input" 
          placeholder="æœç´¢çŸ¥è¯†ç‚¹..." 
          value={searchTerm}
          onChange={(e) => handleSearch(e.target.value)}
        />
        {searchTerm && (
          <button 
            className="search-clear"
            onClick={() => handleSearch('')}
          >
            Ã—
          </button>
        )}
      </div>

      {/* 3Dåœºæ™¯å®¹å™¨ */}
      <div className="globe-scene" ref={mountRef}></div>

      {/* æ§åˆ¶é¢æ¿ */}
      <div className="controls-panel">
        <button className="control-btn" onClick={resetCamera} title="é‡ç½®è§†è§’">
          ğŸ¯
        </button>
        <button className="control-btn" onClick={toggleAutoRotate} title="åˆ‡æ¢è‡ªåŠ¨æ—‹è½¬">
          ğŸ”„
        </button>
      </div>

      {/* æ§åˆ¶æç¤º */}
      <div className="controls-hint">
        <div className="hint-item">ğŸ–±ï¸ æ‹–æ‹½æ—‹è½¬è§†è§’</div>
        <div className="hint-item">ğŸ” æ»šè½®ç¼©æ”¾åœºæ™¯</div>
        <div className="hint-item">ğŸ¯ ç‚¹å‡»é‡ç½®è§†è§’</div>
        <div className="hint-item">ğŸ”„ åˆ‡æ¢è‡ªåŠ¨æ—‹è½¬</div>
        <div className="hint-item">ğŸ“Š èŠ‚ç‚¹æ•°é‡: {nodesRef.current.length}</div>
        <div className="hint-item">ğŸŒˆ æŒ‰å±‚çº§ç€è‰²çš„çŸ¥è¯†èŠ‚ç‚¹</div>
      </div>

      {/* èŠ‚ç‚¹è¯¦æƒ…é¢æ¿ */}
      {selectedNode && (
        <div className="node-details show" onClick={(e) => e.stopPropagation()}>
          <div className="node-details-header">
            <h2 className="node-details-title">{selectedNode.name}</h2>
            <button className="node-details-close" onClick={closeNodeDetails}>Ã—</button>
          </div>
          <div className="node-details-category">{selectedNode.category}</div>
          <p className="node-details-description">{selectedNode.description}</p>
          <div className="node-details-progress">
            <div className="progress-label">
              <span>å­¦ä¹ è¿›åº¦</span>
              <span>{selectedNode.progress}%</span>
            </div>
            <div className="progress-bar">
              <div 
                className="progress-value" 
                style={{ width: `${selectedNode.progress}%` }}
              ></div>
            </div>
          </div>
          <div className="node-details-info">
            <div className="info-item">
              <span className="info-label">å±‚çº§:</span>
              <span className="info-value">ç¬¬ {selectedNode.level + 1} å±‚</span>
            </div>
            <div className="info-item">
              <span className="info-label">å­èŠ‚ç‚¹:</span>
              <span className="info-value">{selectedNode.children.length} ä¸ª</span>
            </div>
            <div className="info-item">
              <span className="info-label">å…³è”ç¬”è®°:</span>
              <span className="info-value">{selectedNode.associatedNotesCount} ç¯‡</span>
            </div>
            <div className="info-item">
              <span className="info-label">ç”Ÿæˆæ–¹å¼:</span>
              <span className="info-value">{selectedNode.isAutoGenerated ? 'AIè‡ªåŠ¨ç”Ÿæˆ' : 'æ‰‹åŠ¨åˆ›å»º'}</span>
            </div>
          </div>
          {selectedNode.keywords && selectedNode.keywords.length > 0 && (
            <div className="node-keywords">
              <div className="keywords-label">å…³é”®è¯:</div>
              <div className="keywords-list">
                {selectedNode.keywords.map((keyword, index) => (
                  <span key={index} className="keyword-tag">{keyword}</span>
                ))}
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default KnowledgeGlobe;
